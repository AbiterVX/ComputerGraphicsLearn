(1)姓名:任哲旋

(2)问题与挑战:
 
1.对于滑动窗口，之前做的为大小为5的窗口，并且当全部发完后再读后五个，发现这样效率较低，于是制作成一个链表的滑动窗口。返回一个ack，先去除在表中之前的，之后在尾部填满回五个大小。

2.进行测试时，虽然第一个可以通过，但是第二个(模拟随机丢包)发送很慢，而且可能读到某一处时会卡住，即不断出现相同的ack，无法停止。之后进行随机测试(当然无法考虑带宽占用问题。。)每次发送都是发送10次相同的包，这样结果竟然有很大的改进。之后测试如果有错误时，一次发送5个不同的包，即把窗口中所有的包再次发送。这样虽然一开始较慢，但是还是能够完整的跑出来的。分析原因，感觉是发包频率太高。这种根据ack判断是否重发的机制存在延时，那么当发包太快时，会将接受端的缓冲区全部占满，全为相同的包，返回也是相同的ack，那么发送端会认为始终没有接收到那个包，就会出现"卡住"这种情况。

3.对于链式滑动窗口，感觉效率还是不够，于是进行改进。个人认为，如果理想情况，每发一个包一定会收到一个ack。那么我重发时发5个包，那么为了防止这种缓冲区溢出，需要将二者频率尽量持平。于是将接受改为5次接受。但是接受的timeout时间降为1/5或是更少。根据ack的特性，一定是非递减的序列。如果其中一个卡住那么这五个ack会相同，那么通常情况下只需去最后一个非空的ack作为判断依据即可，当然如果全为空，那么最后一个也只能为空。这样在丢包的情况下确实得到了改进。

4.上一条虽然进行改进，但是带来了新的问题。虽然在丢包情况下更快，但是理想情况下却更慢了，可能是因为一次发五个包，返回的ack应该是最新的ack，且只有一个ack。那么我虽然想接受五个但是只能接收到一个，其余四个需要白等4个timeout时间，因此会变慢。同时这种机制也会过于占带宽。因此折中考虑(毕竟非理想环境丢包率太高。。)还是改为一次接受(timeout为0.5)，效果可能更好些。

5.之前有考虑过多线程收发，但是感觉可能占用带宽太多并且也会出现发包过快等情况，因此没有修改。



(3)。。







