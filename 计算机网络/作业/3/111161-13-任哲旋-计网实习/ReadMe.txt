经验，遇到的问题与解决方式：

1.学习型交换机：

(1)一开始并没有明确的思路，只是有一个泛洪的概念，对于具体的操作不是很清楚。   之后按照文档中的思路，如果当前包的dst不在字典中则存入之后flood，如果在字典中需要进行后续比较，但是不需要flood。
(2)需要理清dst与src二者在交换机中的关系。
   之前写的时候很容易混淆。判断是否在表中时，为字典中packet.dst得端口是否与当前端口相同。但是在flood存入时存的是源地址。
(3)通过制作学习型交换机，能够熟悉本实习的一些操作，有了一定的经验，从理论到实践，为接下来的rip-router打好基础。



2.RIP-Router 

    首先先做了个"一维"的路由表，即表中只有一个距离，即当前最短距离。确实与课上所讲的二维表格不同，因为感觉在此实习条件下，这种一维的已经够用了，能解决所有情况。但是后来想到如果删除某一节点，可能会带来错误，同时如果真的可以更改距离，那么这种一维的思想不太完备。

(1)没有完全理解DiscoveryPacket与RoutingPacket之间的关系。
   一开始构造时是邻居间互相发DiscoveryPacket，但是需要注意收到后再泛洪需要改成RoutingPacket，一开始写成了discovery，于是一直flood。主要是用所给的函数，将当前交换机中的字典内容导入到包里，然后发包。
(2)对于RoutingPacket中，需要注意距离的更改。
   距离为当前包(某一路由)到目的地的距离加上当前路由到此包(某一路由)的距离。之前计算时并没有加上后者，从而导致距离完全相同。
(3)存在不足:路由表里会有自己的名字。虽然通过一定的限制，禁止将当前名更新进表中，但是还是存在。
(4)需要注意收到包时先将ttl减一，之后判断是否为0,然后进行之后的操作。


二维路由表:
(1)对于二维表(有一行距离与下一跳)需要存储一行的距离。对于一开始对于二维表的建立还是很难下手，毕竟与一维不同。最后规定申请一个二维链表作为表格，两个一位链表作为行与列。
(2)需要注意routingpacket中只要是与当前表里的值不同就改变，相同就不再改变。而一维表只是比他小就进行更新。
(3)了解到routingpacket只是邻居间互发而不是再互传。
(4)通过unlink与重连等测试，能满足要求，但可能存在一些隐藏的bug。

(5)与其他同学相比初始化很慢，导致测试前超时。
   一开始测试初始化时间大概需要一分半，这显然时间很长。
   1.没有注意到泛洪与端口之间的关系。
     之后分析后发现对于发送routingupdate包来说，是否包括当前端口是很重要的因素。如果是未断开时发discovery包需要向所有端口泛洪。如果断开后需要向除此端口的其他所有端口泛洪。如果接收到routingupdate包后，如果有改变，也需要向所有端口泛洪。主要原因可能是能够将信息及时的传递给所有节点。这样时间减少到23秒，快了很多。
   2.表内距离改变未判断是否是邻居。
     一开始只判断当前距离是否等于1+包里的距离，即CurrentLength!=(1+packet.get_distance(Destination))，但是没有考虑到是否是他的邻居，如果是邻居的话距离只有1，这样会造成许多不必要的操作需要发很多的包。作出改进后时间缩短为12秒，减少了一半。

   
















